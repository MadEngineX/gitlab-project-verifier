//go:build ignore
// +build ignore

//go:generate go run generate_checks.go

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const checksDir = "pkg/checks/"
const outputFile = "pkg/generated/register_checks.go"
const importPathPrefix = "MadEngineX/gitlab-project-verifier/pkg/checks/"

const templateText = `// Code generated by go generate; DO NOT EDIT.
package generated

import (
	{{- range .Imports }}
	"{{ . }}"
	{{- end }}
	"MadEngineX/gitlab-project-verifier/pkg/verifier"
)

type CheckWrapper struct {
	Check verifier.Check
	Group string
}

func RegisterChecks() []CheckWrapper {
	return []CheckWrapper{
{{- range .Checks }}
		{Check: new({{ .Type }}), Group: "{{ .Group }}"},
{{- end }}
	}
}
`

type CheckInfo struct {
	Type  string
	Group string
}

type Data struct {
	Checks  []CheckInfo
	Imports []string
}

func main() {
	var checks []CheckInfo
	importsSet := make(map[string]struct{})

	err := filepath.Walk(checksDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// Ignore directories and files that start with an underscore
		if info.IsDir() || strings.HasPrefix(info.Name(), "_") || !strings.HasSuffix(info.Name(), ".go") || info.Name() == "register_checks.go" {
			return nil
		}

		group := filepath.Base(filepath.Dir(path))
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
		if err != nil {
			return err
		}

		for _, decl := range node.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if strings.HasSuffix(typeSpec.Name.Name, "Check") {
							checks = append(checks, CheckInfo{
								Type:  fmt.Sprintf("%s.%s", group, typeSpec.Name.Name),
								Group: group,
							})
							importsSet[importPathPrefix+group] = struct{}{}
						}
					}
				}
			}
		}

		return nil
	})

	if err != nil {
		log.Fatalf("Failed to walk the path: %v", err)
	}

	var imports []string
	for imp := range importsSet {
		imports = append(imports, imp)
	}

	tmpl, err := template.New("register_checks").Parse(templateText)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, Data{Checks: checks, Imports: imports})
	if err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	err = ioutil.WriteFile(outputFile, buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}

	fmt.Println("Checks registration generated successfully.")
}
